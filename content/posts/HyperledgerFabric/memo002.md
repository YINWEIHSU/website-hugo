---
title: "Memo002"
date: 2022-12-09T19:08:54+08:00
draft: true
---
# 交易的儲存與驗證
帳本與資料庫的運作看起來很像，但最大的不同點是。
帳本僅接受交易的添加，不接受修改以及移除。也因為這個原因，我們將寫入區塊鏈的交易視為不可變化的。
# 驗證
所有記錄在帳本上的交易都會確保經過兩個完整性檢查。
1. 對業務對象的更改是有效的：需要確認修改前的狀態與帳本狀態是一致的。
2. 所有必要的組織都同意變更：需要所有必要的背書節點背書。
所有被寫入區塊中的交易都會被確認，並且標記為有效與無效的交易。所有交易都會被記錄在區塊中，但只有有效的交易會影響後續的流程。

## MVCC
Fabric使用MVCC機制來確保帳本的一致性並避免雙重花費產生。舉例來說，攻擊者會透過攻擊手法，讓同一枚代幣可以被挖花用多次。而如果同時有多筆交易對同一個key值進行修改的話，會造成帳本結果不一致。
通常資料庫等中心化系統會透過鎖定機制來避免key值被同時間重複修改，但在去中心化的fabric網路中無法做到。
MVCC（多版本控制）是一種用於處理交易的并發執行和隔離的機制。它允許在一個數據庫中同時存在多個版本的數據，並且允許用戶在不干擾其他用戶的情況下執行交易。當一個用戶執行一個交易時，數據庫會在背景中創建一個新版本的數據，並在交易完成後將該版本提交到數據庫中。這樣，用戶就可以在不干擾其他用戶的情況下安全地執行交易。
當另一個用戶執行一個交易時，數據庫會再次創建一個新版本的數據。這樣，數據庫中就會存在多個版本的數據。當用戶讀取數據時，數據庫會選擇最新版本的數據，並向用戶返回該數據。這樣，用戶就可以在不干擾其他用戶的情況下安全地讀取數據。
總而言之，MVCC 機制允許在一個數據庫中同時存在多個版本的數據，並且允許用戶在不干擾其他用戶的情況下執行交易。這樣，用戶就可以在不降低系統的性能的情況下，安全地執行交易。
版本的儲存是透過讀寫集來進行的。

## 帳本
區塊儲存的是交易資料，物件狀態則是儲存在狀態資料庫。而這兩者是我們應用程式與智能合約主要互動的對象。但區塊鏈是帳本最主要的元件。如果狀態資料庫被刪除或是遺失，我們依然可以透過區塊鏈的交易資料重新生成。但如果區塊鏈遺失，則我們無法再重新獲取與過去的交易歷史。

### 狀態資料庫（State database）
由於他儲存所有物件的狀態，因此是最常被讀取的帳本組件。也因為他儲存所有帳本上的物件狀態，因此也被升為世界狀態。與比特幣等其他區塊鏈不同，帳本不必每次都去計算過往的交易得到現有的狀態，而是直接從狀態資料庫讀取即可。
### 狀態
狀態的結構是一組key-value pairs，key值為物件的名稱（例如：CAR1），而他的值則是name-value pairs。裡面記載了該物件實際上的詳細資訊。（例如：Owner: Sara）
### 狀態集合（State collections）
我們將world state視為帳本的預設集合。我們也可以創建指定的集合。例如：可以在world state儲存車子的品牌、型號等，而在另一個集合owners儲存擁有者、車輛編號等私密資料。

## 交易流程
![Application and smart contracts operate within a consensus framework](/HyperledgerFabric/sample2.png)
1. 應用程式提交交易到區塊鏈網路中。在此範例中，可以想像應用程式實際上說「我希望向區塊鏈網路提交一筆交易，將CAR1的擁有者由Sara轉為Bob。」應用程式只能完成交易流程中的提交部分。
2. 在這一步，Fabric會說「嗨，Bob 與 Sara 這裡有一個轉移CAR1的請求。你們可以幫我生成一個相對應的回覆並且替我簽章嗎？」Fabric會確認背書策略（endorsement policy），並按照背書策略將交易發給相對應組織的節點上的智能合約。
3. 智能合約會訪問帳本，並透過輸入的值去計算輸出結果。合約回傳的內容包含before-image以及after-image。
* 合約去帳本讀取物吃目前的狀態，儲存為before-image。
* 合約將計算後物件的值，儲存為after-image，但還未將狀態寫入帳本。
由上可知，合約只會回傳response，但不會對帳本產生任何更改。因此只能將回傳值視為未來可能發生的狀態，而非已經完成的狀態。
4. 每個節點上合約傳來的回覆，都會加上簽名並組裝在一起。組裝完成後，該交易會被放進塊中。正常情況下，每個節點回傳的結果一致。但不果不一致的狀況下，大多數相同的結果會被接受。
交易根據參與組織的不同會由不同組織簽章，但最終每個網路中的節點都會收到包含每個參與組織有效簽章的回傳結果。分散式交易是個高度併發的過程，每個組織都會收到包含交易的塊並將它寫入自己的帳本，雖然不一定會同時完成，但當家都依循同樣的流程，最終大家的帳本會達成一致。這也是所謂的「最終一致性」。
5. 最終的共識發生在第五步，所有交易都被放入塊並串上區塊鏈，但只有被標記有效的交易會改變物件狀態。我們會確認交易前的狀態，如果與交易是吻合的，則該交易被標記為有效。接下來會確認該有效交易是否擁有有效組織的簽章，如果該檢查也通過的話，交易會改變帳本的狀態，因為擁有endorsement policy的關係，即使並非有權限參與交易的節點，依然有辦法判斷該交易的簽章是否合法。
前面說了，如果交易結果不一致，則會根據endorsement policy做出判斷，如果endorsement policy規定需要所有簽章，則即使大部分相同，該交易依然為無效交易。